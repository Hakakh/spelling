<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>L√≠nh ƒê·∫∑c C√¥ng T·∫≠p ƒê√°nh V·∫ßn</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f0f8ff;
            padding: 10px;
            line-height: 1.6;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
        }

        .container {
            max-width: 700px;
            width: 100%;
            margin: 10px auto;
            background: #fff;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
            box-sizing: border-box;
        }

        h1 {
            text-align: center;
            color: #0056b3;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        #gameCanvas {
            border: 2px solid #007bff;
            background-color: #87ceeb;
            display: block;
            margin: 10px auto;
            width: 100%;
            max-width: 680px;
            height: 300px;
        }

        .game-info {
            margin: 10px 0;
            font-size: 1em;
            color: #555;
        }

        .question {
            margin: 15px 0 10px 0;
            font-size: 1.1em;
            font-weight: bold;
            color: #0056b3;
        }

        .target-word {
            margin-top: 5px;
            font-size: 1.2em;
            color: #007bff;
            font-weight: bold;
        }

        .answer-box {
            background: #eef;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            min-height: 1.2em;
            text-align: left;
            word-wrap: break-word;
            border: 1px solid #cce;
            font-size: 0.95em;
        }

        button {
            margin: 8px 4px;
            padding: 10px 15px;
            font-size: 0.95em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #007bff;
            color: white;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        button:active {
            transform: scale(0.98);
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .feedback {
            background: #e0ffe0;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            text-align: left;
            border: 1px solid #a3e0a3;
            font-weight: bold;
            font-size: 0.95em;
        }

        .results-display {
            background: #fff8e1;
            padding: 15px;
            margin-top: 15px;
            border-radius: 8px;
            text-align: left;
            border: 1px solid #ffecb3;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            font-size: 0.95em;
        }

        .results-display h3 {
            color: #0056b3;
            text-align: center;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            font-size: 1.3em;
        }

        .results-display p {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed #eee;
        }
        .results-display p:last-child {
            border-bottom: none;
        }

        .results-display strong {
            color: #007bff;
        }

        .results-display em {
            color: #555;
        }

        .results-display button {
            display: block;
            margin: 15px auto 8px auto;
            background-color: #28a745;
        }
        .results-display button:hover {
            background-color: #218838;
        }

        #copyFeedback {
            margin-top: 10px;
            font-size: 0.9em;
            color: #155724;
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            padding: 8px;
            border-radius: 5px;
            text-align: center;
        }
        #copyFeedback a {
            color: #0056b3;
            font-weight: bold;
            text-decoration: underline;
        }

        @media (max-width: 600px) {
            body {
                padding: 5px;
            }
            .container {
                padding: 10px;
                margin: 5px auto;
            }
            h1 {
                font-size: 1.5em;
                margin-bottom: 10px;
            }
            #gameCanvas {
                height: 250px;
            }
            button {
                padding: 8px 12px;
                font-size: 0.9em;
                margin: 5px 3px;
            }
            .question {
                font-size: 1em;
                margin: 10px 0;
            }
            .answer-box, .feedback, .results-display {
                font-size: 0.9em;
                padding: 8px;
            }
            .results-display h3 {
                font-size: 1.2em;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
</head>
<body>
    <div class="container">
        <h1>L√≠nh ƒê·∫∑c C√¥ng T·∫≠p ƒê√°nh V·∫ßn</h1>

        <div class="game-info">
            T·ª´ ƒë√£ ƒë√°nh v·∫ßn: <span id="wordsCleared">0</span> / T·ªïng s·ªë: <span id="totalWords">0</span>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="questionArea" class="question">B·∫•m "B·∫Øt ƒë·∫ßu" ƒë·ªÉ nghe y√™u c·∫ßu.</div>
        <div id="targetWordArea" class="target-word" style="display: none;"></div>

        <div>
            <button onclick="window.speakQuestion()" id="startButton">üîä B·∫Øt ƒë·∫ßu</button>
            <button onclick="window.startRecognition()" id="answerButton">üé§ ƒê√°nh v·∫ßn</button>
        </div>
        <div id="transcript" class="answer-box"></div>
        <div id="feedback" class="feedback" style="display: none;"></div>

        <div>
            <button onclick="window.nextWord()" id="nextButton" disabled>‚û°Ô∏è T·ª´ ti·∫øp theo</button>
            <button onclick="window.displayResults()" id="viewResultsButton">üìä Xem k·∫øt qu·∫£</button>
        </div>

        <div id="resultsDisplayArea" class="results-display" style="display: none;"></div>
    </div>

    <script>
        // --- C·∫•u h√¨nh Game v√† T·ª´ v·ª±ng ---
        const wordList = [
            { word: "apple", meaning: "qu·∫£ t√°o" },
            { word: "rice", meaning: "c∆°m" },
            { word: "bread", meaning: "b√°nh m√¨" },
            { word: "soup", meaning: "s√∫p" },
            { word: "tacos", meaning: "b√°nh tacos" },
            { word: "burger", meaning: "b√°nh m√¨ k·∫πp th·ªãt" },
            { word: "chicken", meaning: "th·ªãt g√†" },
            { word: "fish", meaning: "c√°" },
            { word: "pork", meaning: "th·ªãt heo" },
            { word: "beef", meaning: "th·ªãt b√≤" },
            { word: "egg", meaning: "tr·ª©ng" },
            { word: "salad", meaning: "sa-l√°t" },
            { word: "sandwich", meaning: "b√°nh m√¨ k·∫πp" },
            { word: "sausage", meaning: "x√∫c x√≠ch" },
            { word: "seafood", meaning: "h·∫£i s·∫£n" },
            { word: "sushi", meaning: "m√≥n sushi" },
            { word: "curry", meaning: "c√† ri" },
            { word: "steak", meaning: "b√≤ b√≠t t·∫øt" },
            { word: "cake", meaning: "b√°nh ng·ªçt" },
            { word: "pancake", meaning: "b√°nh k·∫øp" }
        ];

        let currentWordIndex = 0;
        let currentWordLetters = [];
        let spelledLetters = [];
        let playerAttempts = new Array(wordList.length).fill(0);

        // --- DOM Elements ---
        const questionArea = document.getElementById("questionArea");
        const targetWordArea = document.getElementById("targetWordArea");
        const transcriptDiv = document.getElementById("transcript");
        const feedbackDiv = document.getElementById("feedback");
        const resultsDisplayArea = document.getElementById("resultsDisplayArea");
        const startButton = document.getElementById("startButton");
        const answerButton = document.getElementById("answerButton");
        const nextButton = document.getElementById("nextButton");
        const viewResultsButton = document.getElementById("viewResultsButton");
        const wordsClearedSpan = document.getElementById("wordsCleared");
        const totalWordsSpan = document.getElementById("totalWords");

        // --- Canvas Setup ---
        const canvas = document.getElementById("gameCanvas");
        let ctx = canvas.getContext("2d");

        let canvasWidth;
        let canvasHeight;

        // --- Game Variables ---
        const groundHeight = 40;
        let groundY;
        const playerSize = 40;
        const playerColor = "#006400";
        const playerShapeSize = 40;
        let playerY;
        let playerGroundY;
        const playerX = 50;

        const letterSize = 40;
        const letterSpacing = 50;
        const lettersY = 120;
        let letterTargets = [];

        // Bi·∫øn cho hi·ªáu ·ª©ng b·∫Øn
        let bulletX;
        let bulletY;
        const bulletSpeed = 15;
        let isShooting = false;
        let targetLetterIndex = -1;

        // Bi·∫øn cho hi·ªáu ·ª©ng b·∫Øn c·∫£ t·ª´
        let isClearingWord = false;
        let animationTargetIndex = 0;

        // --- Audio Setup (using Tone.js) ---
        let shootSynth = null;

        // --- Function Definitions ---

        function resizeCanvas() {
            canvasWidth = canvas.clientWidth;
            canvasHeight = canvas.clientHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            ctx = canvas.getContext("2d");
            groundY = canvasHeight - groundHeight;
            playerGroundY = canvasHeight - groundHeight - playerSize;
            playerY = playerGroundY;
            bulletX = playerX + playerSize * 0.7;
            bulletY = playerY + playerSize * 0.5;

            if (currentWordLetters.length > 0) {
                initializeLetterTargets();
            }
        }

        function initializeLetterTargets() {
            letterTargets = [];
            const wordLength = currentWordLetters.length;
            const totalLettersWidth = wordLength * letterSize + (wordLength - 1) * letterSpacing;
            const startX = (canvasWidth - totalLettersWidth) / 2;

            for (let i = 0; i < wordLength; i++) {
                letterTargets.push({
                    x: startX + i * (letterSize + letterSpacing),
                    y: lettersY,
                    width: letterSize,
                    height: letterSize,
                    cleared: false
                });
            }
        }

        function drawGround() {
            ctx.fillStyle = "#a0522d";
            ctx.fillRect(0, groundY, canvasWidth, groundHeight);
        }

        function drawPlayer() {
            ctx.fillStyle = playerColor;
            ctx.fillRect(playerX + playerShapeSize * 0.2, playerY, playerShapeSize * 0.6, playerShapeSize * 0.8);
            ctx.beginPath();
            ctx.arc(playerX + playerShapeSize / 2, playerY - playerShapeSize * 0.3, playerShapeSize * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(playerX + playerShapeSize * 0.1, playerY + playerShapeSize * 0.8, playerShapeSize * 0.3, playerShapeSize * 0.2);
            ctx.fillRect(playerX + playerShapeSize * 0.6, playerY + playerShapeSize * 0.8, playerShapeSize * 0.3, playerShapeSize * 0.2);
            ctx.fillRect(playerX + playerShapeSize * 0.7, playerY + playerShapeSize * 0.2, playerShapeSize * 0.3, playerShapeSize * 0.15);
            ctx.fillRect(playerX + playerShapeSize * 0.7, playerY + playerShapeSize * 0.4, playerShapeSize * 0.3, playerShapeSize * 0.15);
            ctx.fillStyle = "#333";
            ctx.fillRect(playerX + playerShapeSize, playerY + playerShapeSize * 0.5, playerShapeSize * 0.5, playerShapeSize * 0.1);
        }

        function drawLetterTargets() {
            if (!currentWordLetters.length || !letterTargets.length) return;

            letterTargets.forEach((target, index) => {
                if (target.cleared) return; // Kh√¥ng v·∫Ω k√Ω t·ª± ƒë√£ b·ªã b·∫Øn

                const letterToDraw = currentWordLetters[index].toUpperCase();
                const textX = target.x + target.width / 2;
                const textY = target.y + target.height / 2;

                ctx.font = `bold ${letterSize}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                ctx.fillStyle = "navy";
                ctx.fillText(letterToDraw, textX, textY);
                ctx.strokeStyle = "navy";
                ctx.strokeRect(target.x, target.y, target.width, target.height);
            });
        }

        function drawBullet() {
            if (isShooting && targetLetterIndex >= 0 && targetLetterIndex < letterTargets.length) {
                ctx.fillStyle = "yellow";
                ctx.beginPath();
                ctx.arc(bulletX, bulletY, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawGame() {
            if (!ctx) {
                console.error("Canvas context is not available.");
                return;
            }

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            drawGround();
            drawLetterTargets();
            drawPlayer();
            drawBullet();
        }

        function gameLoop() {
            if (isShooting && targetLetterIndex >= 0 && targetLetterIndex < letterTargets.length) {
                const target = letterTargets[targetLetterIndex];
                const targetX = target.x + target.width / 2;
                const targetY = target.y + target.height / 2;

                const deltaX = targetX - bulletX;
                const deltaY = targetY - bulletY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                if (distance > bulletSpeed) {
                    bulletX += (deltaX / distance) * bulletSpeed;
                    bulletY += (deltaY / distance) * bulletSpeed;
                } else {
                    bulletX = targetX;
                    bulletY = targetY;
                    isShooting = false;
                    if (targetLetterIndex < letterTargets.length) {
                        letterTargets[targetLetterIndex].cleared = true; // K√Ω t·ª± bi·∫øn m·∫•t
                    }

                    bulletX = playerX + playerSize * 0.7;
                    bulletY = playerY + playerSize * 0.5;
                    targetLetterIndex = -1;

                    if (isClearingWord) {
                        setTimeout(() => {
                            animationTargetIndex++;
                            if (animationTargetIndex < currentWordLetters.length) {
                                targetLetterIndex = animationTargetIndex;
                                isShooting = true;
                                if (shootSynth) {
                                    shootSynth.triggerAttackRelease("C4", "32n");
                                }
                            } else {
                                isClearingWord = false;
                                nextButton.disabled = false;
                            }
                        }, 100);
                    }
                }
            }

            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // --- Speech Recognition and Synthesis ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.lang = 'en-US';
            recognition.continuous = false;
            recognition.interimResults = false;

            recognition.onresult = function (event) {
                const transcript = event.results[0][0].transcript.trim().toLowerCase();
                transcriptDiv.textContent = `B·∫°n n√≥i: ${transcript}`;
                provideFeedback(transcript);
                answerButton.disabled = false;
            };

            recognition.onerror = function(event) {
                console.error("L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i:", event.error);
                let errorMessage;
                switch (event.error) {
                    case 'no-speech':
                        errorMessage = "Kh√¥ng ph√°t hi·ªán gi·ªçng n√≥i. Vui l√≤ng th·ª≠ l·∫°i.";
                        break;
                    case 'audio-capture':
                        errorMessage = "L·ªói thu √¢m thanh. Vui l√≤ng ki·ªÉm tra micro.";
                        break;
                    case 'not-allowed':
                        errorMessage = "Quy·ªÅn truy c·∫≠p micro b·ªã t·ª´ ch·ªëi. Vui l√≤ng c·∫•p quy·ªÅn trong c√†i ƒë·∫∑t tr√¨nh duy·ªát.";
                        break;
                    default:
                        errorMessage = `L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i: ${event.error}. Vui l√≤ng th·ª≠ l·∫°i.`;
                }
                feedbackDiv.textContent = errorMessage;
                feedbackDiv.style.display = 'block';
                feedbackDiv.style.backgroundColor = '#f8d7da';
                feedbackDiv.style.borderColor = '#f5c6cb';
                speakText(errorMessage, 'vi-VN');
                answerButton.disabled = false;
            };

            recognition.onstart = function() {
                answerButton.disabled = true;
                transcriptDiv.textContent = "ƒêang nghe...";
                feedbackDiv.style.display = 'none';
            };

            recognition.onend = function() {
                answerButton.disabled = false;
                if (transcriptDiv.textContent === "ƒêang nghe...") {
                    transcriptDiv.textContent = "Kh√¥ng ph√°t hi·ªán th·∫•y gi·ªçng n√≥i.";
                    feedbackDiv.textContent = "Kh√¥ng ph√°t hi·ªán th·∫•y gi·ªçng n√≥i. Vui l√≤ng th·ª≠ l·∫°i!";
                    feedbackDiv.style.display = 'block';
                    feedbackDiv.style.backgroundColor = '#fff3cd';
                    feedbackDiv.style.borderColor = '#ffeeba';
                    speakText("Kh√¥ng ph√°t hi·ªán th·∫•y gi·ªçng n√≥i. Vui l√≤ng th·ª≠ l·∫°i!", 'vi-VN');
                }
            };
        } else {
            console.warn("Speech Recognition API not supported.");
            answerButton.disabled = true;
            answerButton.textContent = "üé§ API kh√¥ng h·ªó tr·ª£";
            questionArea.textContent = "Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ nh·∫≠n d·∫°ng gi·ªçng n√≥i. Vui l√≤ng d√πng Google Chrome.";
            feedbackDiv.textContent = "Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ nh·∫≠n d·∫°ng gi·ªçng n√≥i.";
            feedbackDiv.style.display = 'block';
            feedbackDiv.style.backgroundColor = '#f8d7da';
            feedbackDiv.style.borderColor = '#f5c6cb';
        }

        function speakText(text, lang = 'en-US') {
            speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = lang;
            utterance.onerror = (event) => {
                console.error("L·ªói ph√°t gi·ªçng n√≥i:", event.error);
            };
            speechSynthesis.speak(utterance);
        }

        function isCorrectLetter(spokenText, expectedLetter) {
            const normalizedSpoken = spokenText.trim().toLowerCase();
            const normalizedExpected = expectedLetter.toLowerCase();

            // Ki·ªÉm tra n·∫øu n√≥i ƒë√∫ng ch·ªØ c√°i
            if (normalizedSpoken === normalizedExpected) return true;

            // Ki·ªÉm tra c√°c tr∆∞·ªùng h·ª£p nh·∫≠n di·ªán sai ph·ªï bi·∫øn
            const commonMisrecognitions = {
                'a': ['a'],
                'b': ['be'],
                'c': ['see', 'sea'],
                'd': ['de'],
                'e': ['e'],
                'f': ['ef', 'eff'],
                'g': ['gee'],
                'h': ['aitch', 'h'],
                'i': ['i', 'eye'],
                'j': ['jay'],
                'k': ['kay'],
                'l': ['el', 'ell'],
                'm': ['em', 'emm'],
                'n': ['en', 'enn'],
                'o': ['o', 'oh'],
                'p': ['pee'],
                'q': ['cue', 'queue'],
                'r': ['are'],
                's': ['es', 'ess'],
                't': ['tee'],
                'u': ['u', 'you'],
                'v': ['vee'],
                'w': ['double u', 'w'],
                'x': ['ex', 'eks'],
                'y': ['why'],
                'z': ['zee', 'zed']
            };

            if (commonMisrecognitions[normalizedExpected]?.includes(normalizedSpoken)) return true;

            // Ki·ªÉm tra n·∫øu ng∆∞·ªùi d√πng n√≥i to√†n b·ªô t·ª´
            const currentWord = wordList[currentWordIndex].word.toLowerCase();
            if (normalizedSpoken === currentWord || normalizedSpoken.replace(/\s/g, '') === currentWord) {
                console.log(`Accepted "${normalizedSpoken}" as part of word "${currentWord}"`);
                return normalizedExpected === currentWordLetters[0].toLowerCase();
            }

            // Th·ª≠ t√°ch chu·ªói n·∫øu ng∆∞·ªùi d√πng n√≥i nhi·ªÅu ch·ªØ c√°i (v√≠ d·ª•: "a p p l e")
            const spokenLetters = normalizedSpoken.split(/\s+/);
            if (spokenLetters.length > 1) {
                return spokenLetters[0] === normalizedExpected || commonMisrecognitions[normalizedExpected]?.includes(spokenLetters[0]);
            }

            return false;
        }

        function provideFeedback(spokenText) {
            feedbackDiv.style.display = 'block';
            const nextIndexToSpell = spelledLetters.filter(l => l !== undefined).length;

            if (nextIndexToSpell >= currentWordLetters.length) {
                feedbackDiv.textContent = `B·∫°n ƒë√°nh v·∫ßn r·∫•t t·ªët!`;
                feedbackDiv.style.backgroundColor = '#d4edda';
                feedbackDiv.style.borderColor = '#c3e6cb';
                speakText(`B·∫°n ƒë√°nh v·∫ßn r·∫•t t·ªët!`, 'vi-VN');
                return;
            }

            const expectedLetter = currentWordLetters[nextIndexToSpell];
            let comment, speakFeedbackText;
            let progressMade = false; // Track if this attempt added correct letters

            if (!spokenText || spokenText.trim() === "") {
                comment = "‚ö†Ô∏è Kh√¥ng ph√°t hi·ªán gi·ªçng n√≥i. Vui l√≤ng th·ª≠ l·∫°i!";
                speakFeedbackText = "Kh√¥ng ph√°t hi·ªán gi·ªçng n√≥i. Vui l√≤ng th·ª≠ l·∫°i!";
                feedbackDiv.style.backgroundColor = '#fff3cd';
                feedbackDiv.style.borderColor = '#ffeeba';
            } else {
                // Th·ª≠ t√°ch chu·ªói n·∫øu ng∆∞·ªùi d√πng n√≥i nhi·ªÅu ch·ªØ c√°i
                const spokenLetters = spokenText.trim().toLowerCase().split(/\s+/);
                const currentWord = wordList[currentWordIndex].word.toLowerCase();
                let allCorrect = true;
                let lettersProcessed = 0;

                if (spokenLetters.length > 1 || spokenText.replace(/\s/g, '') === currentWord) {
                    // Ng∆∞·ªùi d√πng n√≥i nhi·ªÅu ch·ªØ c√°i ho·∫∑c to√†n b·ªô t·ª´
                    const lettersToCheck = spokenLetters.length > 1 ? spokenLetters : currentWord.split('');
                    for (let i = nextIndexToSpell; i < currentWordLetters.length && lettersProcessed < lettersToCheck.length; i++) {
                        if (isCorrectLetter(lettersToCheck[lettersProcessed], currentWordLetters[i])) {
                            spelledLetters[i] = currentWordLetters[i];
                            lettersProcessed++;
                        } else {
                            allCorrect = false;
                            break;
                        }
                    }

                    if (lettersProcessed > 0) {
                        progressMade = true; // Correct letters were added
                        // N·∫øu t·∫•t c·∫£ ch·ªØ c√°i c·ªßa t·ª´ ƒë√£ ƒë∆∞·ª£c ƒë√°nh v·∫ßn ƒë√∫ng
                        if (spelledLetters.filter(l => l !== undefined).length === currentWordLetters.length) {
                            comment = `B·∫°n ƒë√°nh v·∫ßn r·∫•t t·ªët!`;
                            speakFeedbackText = `B·∫°n ƒë√°nh v·∫ßn r·∫•t t·ªët!`;
                            wordsClearedSpan.textContent = currentWordIndex + 1;
                            answerButton.disabled = true;
                            nextButton.disabled = true;
                            isClearingWord = true;
                            animationTargetIndex = 0;
                            if (animationTargetIndex < currentWordLetters.length) {
                                targetLetterIndex = animationTargetIndex;
                                isShooting = true;
                                if (shootSynth) {
                                    shootSynth.triggerAttackRelease("C4", "32n");
                                }
                            }
                            feedbackDiv.style.backgroundColor = '#d4edda';
                            feedbackDiv.style.borderColor = '#c3e6cb';
                        } else {
                            comment = `‚úÖ ƒê√∫ng ${lettersProcessed} ch·ªØ c√°i: ${spelledLetters.slice(nextIndexToSpell, nextIndexToSpell + lettersProcessed).map(l => l.toUpperCase()).join(' ')}`;
                            speakFeedbackText = `ƒê√∫ng ${lettersProcessed} ch·ªØ c√°i: ${spelledLetters.slice(nextIndexToSpell, nextIndexToSpell + lettersProcessed).join(' ')}`;
                            if (!allCorrect) {
                                comment += `. Nh∆∞ng ch·ªØ ti·∫øp theo l√† "${currentWordLetters[nextIndexToSpell + lettersProcessed].toUpperCase()}". Th·ª≠ l·∫°i!`;
                                speakFeedbackText += `. Ch·ªØ ti·∫øp theo l√† ${currentWordLetters[nextIndexToSpell + lettersProcessed]}. Th·ª≠ l·∫°i!`;
                                feedbackDiv.style.backgroundColor = '#fff3cd';
                                feedbackDiv.style.borderColor = '#ffeeba';
                                playerAttempts[currentWordIndex]++;
                                // Check if 3 incorrect attempts have been made
                                if (playerAttempts[currentWordIndex] >= 3) {
                                    comment += ` B·∫°n ƒë√£ th·ª≠ sai 3 l·∫ßn. Nh·∫•n "T·ª´ ti·∫øp theo" ƒë·ªÉ ti·∫øp t·ª•c!`;
                                    speakFeedbackText += ` B·∫°n ƒë√£ th·ª≠ sai ba l·∫ßn. Nh·∫•n T·ª´ ti·∫øp theo ƒë·ªÉ ti·∫øp t·ª•c!`;
                                    nextButton.disabled = false;
                                    answerButton.disabled = true;
                                }
                            }
                        }
                    } else {
                        comment = `‚ùå Ch∆∞a ƒë√∫ng. B·∫°n n√≥i "${spokenText}". Ch·ªØ c·∫ßn ƒë√°nh v·∫ßn l√† "${expectedLetter.toUpperCase()}". Th·ª≠ l·∫°i!`;
                        speakFeedbackText = `Ch∆∞a ƒë√∫ng. Ch·ªØ c·∫ßn ƒë√°nh v·∫ßn l√† ${expectedLetter}. Th·ª≠ l·∫°i!`;
                        feedbackDiv.style.backgroundColor = '#f8d7da';
                        feedbackDiv.style.borderColor = '#f5c6cb';
                        playerAttempts[currentWordIndex]++;
                        // Check if 3 incorrect attempts have been made
                        if (playerAttempts[currentWordIndex] >= 3) {
                            comment += ` B·∫°n ƒë√£ th·ª≠ sai 3 l·∫ßn. Nh·∫•n "T·ª´ ti·∫øp theo" ƒë·ªÉ ti·∫øp t·ª•c!`;
                            speakFeedbackText += ` B·∫°n ƒë√£ th·ª≠ sai ba l·∫ßn. Nh·∫•n T·ª´ ti·∫øp theo ƒë·ªÉ ti·∫øp t·ª•c!`;
                            nextButton.disabled = false;
                            answerButton.disabled = true;
                        }
                    }
                } else {
                    // Ng∆∞·ªùi d√πng n√≥i m·ªôt ch·ªØ c√°i
                    if (isCorrectLetter(spokenText, expectedLetter)) {
                        comment = `‚úÖ ƒê√∫ng r·ªìi! Ch·ªØ "${expectedLetter.toUpperCase()}"`;
                        speakFeedbackText = `ƒê√∫ng r·ªìi! Ch·ªØ ${expectedLetter}`;
                        feedbackDiv.style.backgroundColor = '#d4edda';
                        feedbackDiv.style.borderColor = '#c3e6cb';
                        spelledLetters[nextIndexToSpell] = expectedLetter;
                        progressMade = true;

                        if (spelledLetters.filter(l => l !== undefined).length === currentWordLetters.length) {
                            comment = `B·∫°n ƒë√°nh v·∫ßn r·∫•t t·ªët!`;
                            speakFeedbackText = `B·∫°n ƒë√°nh v·∫ßn r·∫•t t·ªët!`;
                            wordsClearedSpan.textContent = currentWordIndex + 1;
                            answerButton.disabled = true;
                            nextButton.disabled = true;
                            isClearingWord = true;
                            animationTargetIndex = 0;
                            if (animationTargetIndex < currentWordLetters.length) {
                                targetLetterIndex = animationTargetIndex;
                                isShooting = true;
                                if (shootSynth) {
                                    shootSynth.triggerAttackRelease("C4", "32n");
                                }
                            }
                        }
                    } else {
                        comment = `‚ùå Ch∆∞a ƒë√∫ng. B·∫°n n√≥i "${spokenText}". Ch·ªØ c·∫ßn ƒë√°nh v·∫ßn l√† "${expectedLetter.toUpperCase()}". Th·ª≠ l·∫°i!`;
                        speakFeedbackText = `Ch∆∞a ƒë√∫ng. Ch·ªØ c·∫ßn ƒë√°nh v·∫ßn l√† ${expectedLetter}. Th·ª≠ l·∫°i!`;
                        feedbackDiv.style.backgroundColor = '#f8d7da';
                        feedbackDiv.style.borderColor = '#f5c6cb';
                        playerAttempts[currentWordIndex]++;
                        // Check if 3 incorrect attempts have been made
                        if (playerAttempts[currentWordIndex] >= 3) {
                            comment += ` B·∫°n ƒë√£ th·ª≠ sai 3 l·∫ßn. Nh·∫•n "T·ª´ ti·∫øp theo" ƒë·ªÉ ti·∫øp t·ª•c!`;
                            speakFeedbackText += ` B·∫°n ƒë√£ th·ª≠ sai ba l·∫ßn. Nh·∫•n T·ª´ ti·∫øp theo ƒë·ªÉ ti·∫øp t·ª•c!`;
                            nextButton.disabled = false;
                            answerButton.disabled = true;
                        }
                    }
                }
            }

            feedbackDiv.textContent = comment;
            speakText(speakFeedbackText, 'vi-VN');
        }

        function loadWord(index) {
            if (index >= wordList.length) {
                questionArea.textContent = "Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh t·∫•t c·∫£ c√°c t·ª´!";
                targetWordArea.style.display = 'none';
                disableButtonsOnComplete();
                displayResults();
                return false;
            }

            const wordData = wordList[index];
            currentWordLetters = wordData.word.split('');
            spelledLetters = new Array(currentWordLetters.length).fill(undefined);
            questionArea.textContent = `H√£y ƒë√°nh v·∫ßn t·ª´: ${wordData.meaning}`;
            targetWordArea.textContent = wordData.word.toUpperCase();
            targetWordArea.style.display = 'block';
            transcriptDiv.textContent = '';
            feedbackDiv.style.display = 'none';
            answerButton.disabled = false;
            nextButton.disabled = true;
            startButton.disabled = false;

            initializeLetterTargets();
            return true;
        }

        function speakQuestion() {
            if (currentWordIndex >= wordList.length) return;
            const currentWordData = wordList[currentWordIndex];
            const letters = currentWordData.word.split('');
            const spellingText = letters.join(', ');
            const textToSpeak = `H√£y ƒë√°nh v·∫ßn t·ª´ ${currentWordData.meaning}. T·ª´ n√†y l√†: ${spellingText}.`;
            speakText(textToSpeak, 'en-US');
        }

        function startRecognition() {
            if (recognition) {
                try {
                    recognition.start();
                } catch (e) {
                    console.error("L·ªói khi b·∫Øt ƒë·∫ßu nh·∫≠n d·∫°ng gi·ªçng n√≥i:", e);
                    feedbackDiv.textContent = "L·ªói khi b·∫Øt ƒë·∫ßu nh·∫≠n d·∫°ng gi·ªçng n√≥i. Vui l√≤ng th·ª≠ l·∫°i.";
                    feedbackDiv.style.display = 'block';
                    feedbackDiv.style.borderColor = '#f5c6cb';
                }
            } else {
                feedbackDiv.textContent = "Nh·∫≠n d·∫°ng gi·ªçng n√≥i kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ tr√™n tr√¨nh duy·ªát n√†y.";
                feedbackDiv.style.display = 'block';
                feedbackDiv.style.backgroundColor = '#f8d7da';
                feedbackDiv.style.borderColor = '#f5c6cb';
            }
        }

        function nextWord() {
            currentWordIndex++;
            loadWord(currentWordIndex);
        }

        function disableButtonsOnComplete() {
            startButton.disabled = true;
            answerButton.disabled = true;
            nextButton.disabled = true;
            viewResultsButton.disabled = false;
        }

        function displayResults() {
            resultsDisplayArea.innerHTML = '';

            let resultHTML = "<h3>B·∫£ng K·∫øt Qu·∫£ Luy·ªán ƒê√°nh V·∫ßn</h3>";
            const list = wordList.map((wordData, i) => {
                const attempts = playerAttempts[i];
                const isCleared = (i < currentWordIndex) || (i === currentWordIndex && spelledLetters.filter(l => l !== undefined).length === wordData.word.length);
                const status = isCleared ? "‚úÖ ƒê√£ ƒë√°nh v·∫ßn xong" : "‚ùå Ch∆∞a ho√†n th√†nh";
                const attemptsText = attempts > 0 ? `(S·ªë l·∫ßn th·ª≠: ${attempts})` : "(Ch∆∞a th·ª≠)";

                let spelledProgress = "";
                if (i < currentWordIndex || (i === currentWordIndex && isCleared)) {
                    spelledProgress = wordData.word.split('').map(letter => `<span style="color: green;">${letter.toUpperCase()}</span>`).join(' ');
                } else if (i === currentWordIndex && spelledLetters.filter(l => l !== undefined).length > 0) {
                    spelledProgress = wordData.word.split('').map((letter, letterIndex) => {
                        return spelledLetters[letterIndex] !== undefined ? `<span style="color: green;">${letter.toUpperCase()}</span>` : `<span style="color: gray;">_</span>`;
                    }).join(' ');
                    spelledProgress += ` (${spelledLetters.filter(l => l !== undefined).length}/${wordData.word.length} ch·ªØ)`;
                } else {
                    spelledProgress = wordData.word.split('').map(() => `<span style="color: gray;">_</span>`).join(' ');
                }

                return `<p><strong>T·ª´ ${i + 1}:</strong> ${wordData.word.toUpperCase()} (${wordData.meaning})<br/>
                        <em>Tr·∫°ng th√°i:</em> ${status} ${attemptsText}<br/>
                        <em>Ti·∫øn ƒë·ªô:</em> ${spelledProgress}
                        </p>`;
            }).join('');

            resultHTML += list;
            resultHTML += `<button onclick="window.shareGeneratedResults()">üì§ Chia s·∫ª k·∫øt qu·∫£ n√†y</button>`;
            resultHTML += `<div id="copyFeedback" style="display:none;"></div>`;

            resultsDisplayArea.innerHTML = resultHTML;
            resultsDisplayArea.style.display = 'block';
            resultsDisplayArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function shareGeneratedResults() {
            const listItems = wordList.map((wordData, i) => {
                const attempts = playerAttempts[i];
                const isCleared = (i < currentWordIndex) || (i === currentWordIndex && spelledLetters.filter(l => l !== undefined).length === wordData.word.length);
                const status = isCleared ? "ƒê√£ ƒë√°nh v·∫ßn xong" : "Ch∆∞a ho√†n th√†nh";
                const attemptsText = attempts > 0 ? `(S·ªë l·∫ßn th·ª≠: ${attempts})` : "(Ch∆∞a th·ª≠)";

                let spelledProgress = "";
                if (i < currentWordIndex || (i === currentWordIndex && isCleared)) {
                    spelledProgress = wordData.word.split('').map(letter => letter.toUpperCase()).join(' ');
                } else if (i === currentWordIndex && spelledLetters.filter(l => l !== undefined).length > 0) {
                    spelledProgress = wordData.word.split('').map((letter, letterIndex) => {
                        return spelledLetters[letterIndex] !== undefined ? letter.toUpperCase() : '_';
                    }).join(' ');
                    spelledProgress += ` (${spelledLetters.filter(l => l !== undefined).length}/${wordData.word.length} ch·ªØ)`;
                } else {
                    spelledProgress = wordData.word.split('').map(() => '_').join(' ');
                }

                return `
                    <div style="margin-bottom: 15px; padding-bottom:10px; border-bottom: 1px solid #eee;">
                        <p style="font-weight: bold; color: #0056b3; margin-bottom: 5px;">T·ª´ ${i + 1}: ${wordData.word.toUpperCase()} (${wordData.meaning})</p>
                        <p style="margin-top:5px;"><em>Tr·∫°ng th√°i:</em> ${status} ${attemptsText}</p>
                        <p style="margin-top:5px;"><em>Ti·∫øn ƒë·ªô:</em> ${spelledProgress}</p>
                    </div>`;
            }).join('');

            const htmlContent = `
                <!DOCTYPE html>
                <html lang="vi">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>K·∫øt qu·∫£ Luy·ªán ƒê√°nh V·∫ßn c·ªßa B√©</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f7f6; color: #333; line-height: 1.6; }
                        .container-result { max-width: 700px; margin: 20px auto; background: #fff; padding: 25px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
                        h2 { color: #0056b3; text-align: center; border-bottom: 2px solid #0056b3; padding-bottom: 10px; margin-bottom: 25px; }
                        p { margin-bottom: 8px; }
                        em { font-style: italic; color: #555; }
                        button { 
                            display: block; 
                            margin: 20px auto; 
                            padding: 10px 20px; 
                            font-size: 1em; 
                            border: none; 
                            border-radius: 5px; 
                            cursor: pointer; 
                            background: #007bff; 
                            color: white; 
                            transition: background-color 0.3s ease; 
                        }
                        button:hover { background: #0056b3; }
                    </style>
                </head>
                <body>
                    <div class="container-result">
                        <h2>K·∫øt qu·∫£ Luy·ªán ƒê√°nh V·∫ßn - L√≠nh ƒê·∫∑c C√¥ng</h2>
                        ${listItems}
                        <p style="text-align:center; margin-top:25px; font-size:0.9em; color: #777;">K·∫øt qu·∫£ ƒë∆∞·ª£c t·∫°o v√†o l√∫c: ${new Date().toLocaleString('vi-VN')}</p>
                        <button onclick="window.close()">‚¨ÖÔ∏è Quay tr·ªü v·ªÅ m√†n h√¨nh ch√≠nh</button>
                    </div>
                </body>
                </html>`;

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const copyFeedbackDiv = document.getElementById("copyFeedback");
            copyFeedbackDiv.style.display = 'block';

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(url).then(() => {
                    copyFeedbackDiv.innerHTML = `üîó Link k·∫øt qu·∫£ ƒë√£ ƒë∆∞·ª£c sao ch√©p! B·∫°n c√≥ th·ªÉ d√°n (Ctrl+V ho·∫∑c Command+V) ƒë·ªÉ chia s·∫ª. Ho·∫∑c <a href="${url}" target="_blank" rel="noopener noreferrer">xem k·∫øt qu·∫£ t·∫°i ƒë√¢y</a>.`;
                }).catch(err => {
                    console.error('Kh√¥ng th·ªÉ sao ch√©p link t·ª± ƒë·ªông: ', err);
                    copyFeedbackDiv.innerHTML = `Kh√¥ng th·ªÉ t·ª± ƒë·ªông sao ch√©p link. Vui l√≤ng sao ch√©p th·ªß c√¥ng: <a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
                });
            } else {
                copyFeedbackDiv.innerHTML = `Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ sao ch√©p t·ª± ƒë·ªông. Vui l√≤ng sao ch√©p link sau ƒë·ªÉ chia s·∫ª: <a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
            }
            window.open(url, '_blank');
        }

        // --- Initialization ---

        window.loadWord = loadWord;
        window.speakQuestion = speakQuestion;
        window.startRecognition = startRecognition;
        window.nextWord = nextWord;
        window.displayResults = displayResults;
        window.shareGeneratedResults = shareGeneratedResults;
        window.isCorrectLetter = isCorrectLetter;
        window.initializeLetterTargets = initializeLetterTargets;
        window.handleFirstInteraction = handleFirstInteraction;

        function initGame() {
            console.log("Initializing game...");
            totalWordsSpan.textContent = wordList.length;
            resizeCanvas();
            document.addEventListener('click', window.handleFirstInteraction, { once: true });
        }

        function handleFirstInteraction() {
            console.log("First user interaction detected.");
            if (!shootSynth) {
                try {
                    shootSynth = new Tone.Synth({
                        oscillator: { type: "square" },
                        envelope: { attack: 0.001, decay: 0.05, sustain: 0.01, release: 0.1 }
                    }).toDestination();
                    console.log("Tone.js shootSynth initialized.");
                } catch (e) {
                    console.error("L·ªói kh·ªüi t·∫°o Tone.js:", e);
                }
            }

            if (Tone.context.state !== 'running') {
                Tone.context.resume().then(() => {
                    console.log('AudioContext resumed successfully.');
                }).catch(e => {
                    console.error('Error resuming AudioContext:', e);
                });
            }

            loadWord(currentWordIndex);
            gameLoop();
        }

        window.onload = initGame;
    </script>
</body>
</html>
